#!/usr/bin/env python3
"""
Compare JWT tokens generated by our implementation vs the official SDK.
This might reveal subtle differences causing the 401 errors.
"""

import os
import sys
import json
import time
from pathlib import Path
from dotenv import load_dotenv

# Clear env vars and reload
for key in ['COINBASE_PROD_CDP_API_KEY', 'COINBASE_PROD_CDP_PRIVATE_KEY',
            'COINBASE_CDP_API_KEY', 'COINBASE_CDP_PRIVATE_KEY']:
    if key in os.environ:
        del os.environ[key]

load_dotenv()
sys.path.insert(0, str(Path(__file__).parent.parent))

def compare_jwt_tokens():
    """Compare JWT tokens from both implementations."""
    
    print("=" * 70)
    print("JWT TOKEN COMPARISON")
    print("=" * 70)
    
    api_key = os.getenv("COINBASE_PROD_CDP_API_KEY") or os.getenv("COINBASE_CDP_API_KEY")
    private_key = os.getenv("COINBASE_PROD_CDP_PRIVATE_KEY") or os.getenv("COINBASE_CDP_PRIVATE_KEY")
    
    if not api_key or not private_key:
        print("‚ùå Missing credentials")
        return
    
    method = "GET"
    path = "/api/v3/brokerage/accounts"
    
    print(f"\nüìç Test Request: {method} {path}")
    
    # 1. Our implementation
    print("\n" + "=" * 70)
    print("1. OUR IMPLEMENTATION (cdp_auth_v2)")
    print("=" * 70)
    
    try:
        from bot_v2.features.brokerages.coinbase.cdp_auth_v2 import CDPAuthV2
        import jwt
        
        our_auth = CDPAuthV2(
            api_key_name=api_key,
            private_key_pem=private_key,
            base_host="api.coinbase.com"
        )
        
        our_token = our_auth.generate_jwt(method, path)
        our_decoded = jwt.decode(our_token, options={"verify_signature": False})
        our_headers = jwt.get_unverified_header(our_token)
        
        print("\nüìã Token Structure:")
        print(f"   Length: {len(our_token)} characters")
        
        print("\nüìã Headers:")
        for k, v in our_headers.items():
            if k == "kid":
                print(f"   {k}: ...{v[-20:]}")
            elif k == "nonce":
                print(f"   {k}: {v[:20]}... (len: {len(v)})")
            else:
                print(f"   {k}: {v}")
        
        print("\nüìã Claims:")
        for k, v in our_decoded.items():
            if k in ["nbf", "exp"]:
                print(f"   {k}: {v} (offset: {v - int(time.time())}s from now)")
            elif k == "sub":
                print(f"   {k}: ...{v[-20:]}")
            else:
                print(f"   {k}: {v}")
        
    except Exception as e:
        print(f"‚ùå Error: {e}")
        return
    
    # 2. Official SDK implementation
    print("\n" + "=" * 70)
    print("2. OFFICIAL SDK IMPLEMENTATION")
    print("=" * 70)
    
    try:
        # Try to inspect what the SDK generates
        from coinbase.rest import RESTClient
        import logging
        import io
        import sys
        
        # Capture SDK's JWT generation
        log_capture = io.StringIO()
        handler = logging.StreamHandler(log_capture)
        handler.setLevel(logging.DEBUG)
        
        # Get SDK's logger
        sdk_logger = logging.getLogger('coinbase')
        sdk_logger.setLevel(logging.DEBUG)
        sdk_logger.addHandler(handler)
        
        # Create client
        client = RESTClient(
            api_key=api_key,
            api_secret=private_key,
            verbose=True
        )
        
        # Try to capture the JWT from a request
        print("\nüìã Making request to capture JWT...")
        
        # Monkey-patch to capture headers
        import urllib3
        original_request = urllib3.HTTPConnectionPool.urlopen
        captured_headers = {}
        
        def capture_request(self, method, url, *args, **kwargs):
            if 'headers' in kwargs:
                captured_headers.update(kwargs['headers'])
            return original_request(self, method, url, *args, **kwargs)
        
        urllib3.HTTPConnectionPool.urlopen = capture_request
        
        try:
            # Make a request to capture the JWT
            client.get_unix_time()
        except:
            pass  # We don't care if it fails, we just want the JWT
        
        # Restore original
        urllib3.HTTPConnectionPool.urlopen = original_request
        
        # Check if we captured an Authorization header
        if 'Authorization' in captured_headers:
            sdk_token = captured_headers['Authorization'].replace('Bearer ', '')
            print(f"\n‚úÖ Captured SDK JWT token")
            
            # Decode and compare
            sdk_decoded = jwt.decode(sdk_token, options={"verify_signature": False})
            sdk_headers = jwt.get_unverified_header(sdk_token)
            
            print("\nüìã SDK Token Structure:")
            print(f"   Length: {len(sdk_token)} characters")
            
            print("\nüìã SDK Headers:")
            for k, v in sdk_headers.items():
                if k == "kid":
                    print(f"   {k}: ...{v[-20:]}")
                elif k == "nonce":
                    print(f"   {k}: {v[:20]}... (len: {len(v)})")
                else:
                    print(f"   {k}: {v}")
            
            print("\nüìã SDK Claims:")
            for k, v in sdk_decoded.items():
                if k in ["nbf", "exp"]:
                    print(f"   {k}: {v} (offset: {v - int(time.time())}s from now)")
                elif k == "sub":
                    print(f"   {k}: ...{v[-20:]}")
                else:
                    print(f"   {k}: {v}")
            
            # Compare differences
            print("\n" + "=" * 70)
            print("3. DIFFERENCES")
            print("=" * 70)
            
            # Compare headers
            print("\nüìã Header Differences:")
            for key in set(list(our_headers.keys()) + list(sdk_headers.keys())):
                our_val = our_headers.get(key)
                sdk_val = sdk_headers.get(key)
                if our_val != sdk_val:
                    print(f"   {key}:")
                    print(f"      Our: {our_val}")
                    print(f"      SDK: {sdk_val}")
            
            # Compare claims
            print("\nüìã Claim Differences:")
            for key in set(list(our_decoded.keys()) + list(sdk_decoded.keys())):
                if key in ["nbf", "exp", "iat"]:  # Skip time-based claims
                    continue
                our_val = our_decoded.get(key)
                sdk_val = sdk_decoded.get(key)
                if our_val != sdk_val:
                    print(f"   {key}:")
                    print(f"      Our: {our_val}")
                    print(f"      SDK: {sdk_val}")
            
            if not any(our_decoded.get(k) != sdk_decoded.get(k) 
                      for k in ["iss", "sub", "uri"] if k in our_decoded):
                print("\n‚úÖ Core claims (iss, sub, uri) match perfectly!")
            
        else:
            print("\n‚ö†Ô∏è Could not capture SDK's JWT token")
            print("   The SDK might be using a different request method")
        
        # Show SDK logs
        log_output = log_capture.getvalue()
        if "JWT" in log_output or "Bearer" in log_output:
            print("\nüìã SDK Debug Output:")
            for line in log_output.split('\n')[:10]:
                if line.strip():
                    print(f"   {line}")
        
    except Exception as e:
        print(f"‚ùå Error with SDK: {e}")
        import traceback
        traceback.print_exc()
    
    print("\n" + "=" * 70)
    print("ANALYSIS")
    print("=" * 70)
    
    print("\nIf both implementations generate similar JWTs but both fail:")
    print("‚Üí The issue is definitely with CDP configuration")
    print("‚Üí Contact Coinbase support with this evidence")
    
    print("\nIf there are differences in the JWT structure:")
    print("‚Üí We can adjust our implementation to match the SDK")


if __name__ == "__main__":
    compare_jwt_tokens()
