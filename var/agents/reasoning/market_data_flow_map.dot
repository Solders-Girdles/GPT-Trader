digraph MarketDataFlow {
  rankdir=LR;
  subgraph cluster_polling {
    label="REST Polling";
    style=rounded;
    "engine_cycle" [shape=box, label="TradingEngine._cycle\nsrc/gpt_trader/features/live_trade/engines/strategy.py"];
    "fetch_batch_tickers" [shape=box, label="TradingEngine._fetch_batch_tickers\nsrc/gpt_trader/features/live_trade/engines/strategy.py"];
    "broker_get_tickers" [shape=box, label="Broker.get_tickers (optional)\nsrc/gpt_trader/features/brokerages/coinbase/rest/product_service.py"];
    "broker_get_ticker" [shape=box, label="BrokerProtocol.get_ticker\nsrc/gpt_trader/features/brokerages/core/protocols.py"];
    "broker_get_candles" [shape=box, label="BrokerProtocol.get_candles\nsrc/gpt_trader/features/brokerages/core/protocols.py"];
    "process_symbol" [shape=box, label="TradingEngine._process_symbol\nsrc/gpt_trader/features/live_trade/engines/strategy.py"];
  }
  subgraph cluster_streaming {
    label="WebSocket Streaming";
    style=rounded;
    "start_streaming" [shape=box, label="start_streaming_background\nsrc/gpt_trader/features/live_trade/engines/telemetry_streaming.py"];
    "run_stream_loop" [shape=box, label="telemetry_streaming._run_stream_loop\nsrc/gpt_trader/features/live_trade/engines/telemetry_streaming.py"];
    "stream_orderbook" [shape=box, label="WebSocketClientMixin.stream_orderbook\nsrc/gpt_trader/features/brokerages/coinbase/client/websocket_mixin.py"];
    "stream_trades" [shape=box, label="WebSocketClientMixin.stream_trades\nsrc/gpt_trader/features/brokerages/coinbase/client/websocket_mixin.py"];
    "ws_events" [shape=box, label="ws_events (OrderbookUpdate/TradeEvent)\nsrc/gpt_trader/features/brokerages/coinbase/ws_events.py"];
    "update_mark_metrics" [shape=box, label="update_mark_and_metrics\nsrc/gpt_trader/features/live_trade/engines/telemetry_health.py"];
    "update_orderbook_snapshot" [shape=box, label="update_orderbook_snapshot\nsrc/gpt_trader/features/live_trade/engines/telemetry_health.py"];
    "update_trade_aggregator" [shape=box, label="update_trade_aggregator\nsrc/gpt_trader/features/live_trade/engines/telemetry_health.py"];
  }
  subgraph cluster_state {
    label="Runtime State";
    style=rounded;
    "price_tick_store" [shape=box, label="PriceTickStore\nsrc/gpt_trader/features/live_trade/engines/price_tick_store.py"];
    "runtime_mark_windows" [shape=box, label="RuntimeStateProtocol.mark_windows\nsrc/gpt_trader/app/protocols.py"];
    "runtime_orderbook_snapshots" [shape=box, label="RuntimeStateProtocol.orderbook_snapshots\nsrc/gpt_trader/app/protocols.py"];
    "runtime_trade_aggregators" [shape=box, label="RuntimeStateProtocol.trade_aggregators\nsrc/gpt_trader/app/protocols.py"];
  }
  subgraph cluster_risk {
    label="Risk + Staleness";
    style=rounded;
    "risk_last_mark_update" [shape=box, label="LiveRiskManager.last_mark_update\nsrc/gpt_trader/features/live_trade/risk/manager/__init__.py"];
    "risk_check_mark_staleness" [shape=box, label="LiveRiskManager.check_mark_staleness\nsrc/gpt_trader/features/live_trade/risk/manager/__init__.py"];
  }
  subgraph cluster_event_store {
    label="Event Store";
    style=rounded;
    "emit_metric" [shape=box, label="emit_metric\nsrc/gpt_trader/utilities/telemetry.py"];
    "emit_orderbook_snapshot" [shape=box, label="emit_orderbook_snapshot\nsrc/gpt_trader/features/live_trade/engines/telemetry_health.py"];
    "emit_trade_flow_summary" [shape=box, label="emit_trade_flow_summary\nsrc/gpt_trader/features/live_trade/engines/telemetry_health.py"];
    "event_store_append_metric" [shape=box, label="EventStoreProtocol.append_metric\nsrc/gpt_trader/app/protocols.py"];
    "event_store_append" [shape=box, label="EventStoreProtocol.append\nsrc/gpt_trader/app/protocols.py"];
  }
  subgraph cluster_strategy {
    label="Strategy Inputs";
    style=rounded;
    "strategy_decide" [shape=box, label="Strategy.decide\nsrc/gpt_trader/features/live_trade/strategies/base.py"];
  }
  "engine_cycle" -> "fetch_batch_tickers" [label="poll tickers"];
  "fetch_batch_tickers" -> "broker_get_tickers" [label="batch request"];
  "fetch_batch_tickers" -> "broker_get_ticker" [label="fallback per symbol"];
  "broker_get_tickers" -> "process_symbol" [label="ticker map"];
  "broker_get_ticker" -> "process_symbol" [label="single ticker"];
  "process_symbol" -> "broker_get_candles" [label="candles request"];
  "broker_get_candles" -> "process_symbol" [label="candles data"];
  "process_symbol" -> "price_tick_store" [label="record mark"];
  "process_symbol" -> "risk_last_mark_update" [label="mark timestamp"];
  "price_tick_store" -> "strategy_decide" [label="recent_marks"];
  "process_symbol" -> "strategy_decide" [label="current_mark + candles"];
  "start_streaming" -> "run_stream_loop" [label="start WS loop"];
  "run_stream_loop" -> "stream_orderbook" [label="primary stream"];
  "run_stream_loop" -> "stream_trades" [label="fallback stream"];
  "stream_orderbook" -> "ws_events" [label="messages"];
  "stream_trades" -> "ws_events" [label="messages"];
  "ws_events" -> "update_mark_metrics" [label="mark updates"];
  "ws_events" -> "update_orderbook_snapshot" [label="orderbook updates"];
  "ws_events" -> "update_trade_aggregator" [label="trade updates"];
  "update_mark_metrics" -> "runtime_mark_windows" [label="mark windows"];
  "update_mark_metrics" -> "risk_last_mark_update" [label="mark timestamp"];
  "update_mark_metrics" -> "emit_metric" [label="ws_mark_update"];
  "update_orderbook_snapshot" -> "runtime_orderbook_snapshots" [label="depth snapshot"];
  "update_orderbook_snapshot" -> "emit_orderbook_snapshot" [label="persist snapshot"];
  "update_trade_aggregator" -> "runtime_trade_aggregators" [label="trade stats"];
  "update_trade_aggregator" -> "emit_trade_flow_summary" [label="persist trade flow"];
  "run_stream_loop" -> "emit_metric" [label="stream health"];
  "emit_metric" -> "event_store_append_metric" [label="append_metric"];
  "emit_orderbook_snapshot" -> "event_store_append" [label="append orderbook"];
  "emit_trade_flow_summary" -> "event_store_append" [label="append trade flow"];
  "risk_last_mark_update" -> "risk_check_mark_staleness" [label="staleness input"];
}
