"""
Signal generation for backtesting.
"""

import logging
from typing import Any

import pandas as pd

from ...errors import DataError, StrategyError
from ...validation import (
    DataFrameValidator,
    StrategyNameValidator,
    validate_inputs,
)
from .strategies import create_local_strategy
from .validation import validate_signals

logger = logging.getLogger(__name__)


@validate_inputs(
    strategy_name=StrategyNameValidator(),
    data=DataFrameValidator(
        required_columns=["open", "high", "low", "close", "volume"], min_rows=1
    ),
)
def generate_signals(strategy_name: str, data: pd.DataFrame, **strategy_params: Any) -> pd.Series:
    """
    Generate trading signals using specified strategy.

    Args:
        strategy_name: Name of strategy to use
        data: Market data with OHLCV columns
        **strategy_params: Additional strategy parameters

    Returns:
        Series of signals (1=buy, -1=sell, 0=hold)

    Raises:
        StrategyError: If strategy creation or execution fails
        DataError: If insufficient data or data quality issues
        ValidationError: If inputs are invalid
    """
    logger.debug(
        f"Generating signals for {strategy_name} with {len(data)} data points",
        extra={"strategy": strategy_name, "data_rows": len(data), "params": strategy_params},
    )
    # Validate data quality before processing
    try:
        _validate_data_quality(data)
    except Exception as e:
        raise DataError(
            "Data quality validation failed for signal generation",
            context={
                "strategy": strategy_name,
                "data_shape": data.shape,
                "validation_error": str(e),
            },
        ) from e

    # Create strategy instance with error handling
    try:
        strategy = create_local_strategy(strategy_name, **strategy_params)
    except Exception as e:
        raise StrategyError(
            f"Failed to create strategy '{strategy_name}'",
            strategy_name=strategy_name,
            context={"params": strategy_params, "creation_error": str(e)},
        ) from e

    # Check if we have enough data
    try:
        required_periods = strategy.get_required_periods()
    except Exception as e:
        raise StrategyError(
            f"Failed to get required periods for {strategy_name}",
            strategy_name=strategy_name,
            context={"error": str(e)},
        ) from e

    if len(data) < required_periods:
        raise DataError(
            f"Insufficient data for {strategy_name}: need {required_periods} periods, got {len(data)}",
            context={
                "strategy": strategy_name,
                "required_periods": required_periods,
                "available_periods": len(data),
                "shortfall": required_periods - len(data),
            },
        )

    # Generate signals with error handling
    try:
        logger.info(f"Running {strategy_name} strategy on {len(data)} periods")
        signals = strategy.run(data)
    except Exception as e:
        raise StrategyError(
            f"Strategy execution failed for {strategy_name}",
            strategy_name=strategy_name,
            context={
                "data_shape": data.shape,
                "params": strategy_params,
                "execution_error": str(e),
            },
        ) from e

    # Validate generated signals
    try:
        if not validate_signals(signals):
            raise StrategyError(
                f"Invalid signals generated by {strategy_name}",
                strategy_name=strategy_name,
                context={
                    "signal_count": len(signals),
                    "unique_values": signals.dropna().unique().tolist(),
                    "signal_rate": (signals != 0).mean(),
                },
            )
    except Exception as e:
        raise StrategyError(
            f"Signal validation failed for {strategy_name}",
            strategy_name=strategy_name,
            context={
                "signals_shape": getattr(signals, "shape", "unknown"),
                "validation_error": str(e),
            },
        ) from e

    logger.info(
        f"Successfully generated {len(signals)} signals for {strategy_name}",
        extra={
            "strategy": strategy_name,
            "total_signals": len(signals),
            "buy_signals": (signals == 1).sum(),
            "sell_signals": (signals == -1).sum(),
            "hold_signals": (signals == 0).sum(),
        },
    )

    return signals


def _validate_data_quality(data: pd.DataFrame) -> None:
    """
    Validate data quality for signal generation.

    Args:
        data: Market data to validate

    Raises:
        DataError: If data quality issues are found
    """
    # Check for required columns (already validated by decorator, but double-check)
    required_cols = ["open", "high", "low", "close", "volume"]
    missing_cols = [col for col in required_cols if col not in data.columns]
    if missing_cols:
        raise DataError(
            f"Missing required columns: {missing_cols}",
            context={"available_columns": list(data.columns)},
        )

    # Check for null values
    null_counts = data[required_cols].isnull().sum()
    if null_counts.any():
        raise DataError("Null values found in data", context={"null_counts": null_counts.to_dict()})

    # Check for duplicate index values
    if data.index.duplicated().any():
        raise DataError(
            "Duplicate dates found in data",
            context={"duplicate_count": data.index.duplicated().sum()},
        )

    # Check for reasonable price values
    price_cols = ["open", "high", "low", "close"]
    if (data[price_cols] <= 0).any().any():
        raise DataError(
            "Non-positive prices found in data",
            context={"min_prices": data[price_cols].min().to_dict()},
        )

    # Check OHLC relationships
    if not (data["high"] >= data["low"]).all():
        invalid_count = (data["high"] < data["low"]).sum()
        raise DataError(
            "Invalid High < Low relationships found", context={"invalid_count": invalid_count}
        )

    # Check for extreme price movements (basic sanity check)
    returns = data["close"].pct_change().abs()
    extreme_moves = returns > 0.5  # 50% daily moves
    if extreme_moves.any():
        logger.warning(
            f"Extreme price movements detected: {extreme_moves.sum()} days with >50% moves",
            extra={"extreme_returns": returns[extreme_moves].tolist()},
        )


def get_signal_statistics(signals: pd.Series) -> dict[str, Any]:
    """
    Get statistics about generated signals.

    Args:
        signals: Generated trading signals

    Returns:
        Dictionary with signal statistics
    """
    try:
        total_signals = len(signals)
        buy_signals = (signals == 1).sum()
        sell_signals = (signals == -1).sum()
        hold_signals = (signals == 0).sum()

        return {
            "total_signals": total_signals,
            "buy_signals": buy_signals,
            "sell_signals": sell_signals,
            "hold_signals": hold_signals,
            "buy_rate": buy_signals / total_signals if total_signals > 0 else 0,
            "sell_rate": sell_signals / total_signals if total_signals > 0 else 0,
            "activity_rate": (
                (buy_signals + sell_signals) / total_signals if total_signals > 0 else 0
            ),
        }
    except Exception as e:
        logger.warning(f"Failed to calculate signal statistics: {e}")
        return {
            "total_signals": 0,
            "buy_signals": 0,
            "sell_signals": 0,
            "hold_signals": 0,
            "buy_rate": 0,
            "sell_rate": 0,
            "activity_rate": 0,
            "error": str(e),
        }
